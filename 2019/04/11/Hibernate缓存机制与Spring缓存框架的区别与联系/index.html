<!DOCTYPE html>
<html lang>
  <head><meta name="generator" content="Hexo 3.8.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="Hibernate缓存机制与Spring缓存框架的区别与联系">








  <link rel="alternate" href="/default" title="念牧童 Blog">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1">



<link rel="canonical" href="http://jiahuixyz.github.io/2019/04/11/Hibernate缓存机制与Spring缓存框架的区别与联系/">


<meta name="description" content="Hibernate一级缓存 Hibernate二级缓存 Spring缓存机制 Hibernate缓存与Spring缓存的比较  Hibernate一级缓存一级缓存是Session级别的缓存(即当前Session有效)，默认启用。 一级缓存的key为ID(主键)。 当执行load/get/list/iterator/save/update/saveOrUpdate等方法时会把得到的实体对象放入一级">
<meta property="og:type" content="article">
<meta property="og:title" content="Hibernate缓存机制与Spring缓存框架的区别与联系">
<meta property="og:url" content="http://jiahuixyz.github.io/2019/04/11/Hibernate缓存机制与Spring缓存框架的区别与联系/index.html">
<meta property="og:site_name" content="念牧童 Blog">
<meta property="og:description" content="Hibernate一级缓存 Hibernate二级缓存 Spring缓存机制 Hibernate缓存与Spring缓存的比较  Hibernate一级缓存一级缓存是Session级别的缓存(即当前Session有效)，默认启用。 一级缓存的key为ID(主键)。 当执行load/get/list/iterator/save/update/saveOrUpdate等方法时会把得到的实体对象放入一级">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-04-11T13:57:48.341Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hibernate缓存机制与Spring缓存框架的区别与联系">
<meta name="twitter:description" content="Hibernate一级缓存 Hibernate二级缓存 Spring缓存机制 Hibernate缓存与Spring缓存的比较  Hibernate一级缓存一级缓存是Session级别的缓存(即当前Session有效)，默认启用。 一级缓存的key为ID(主键)。 当执行load/get/list/iterator/save/update/saveOrUpdate等方法时会把得到的实体对象放入一级">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d26aecfb935107a8552abee5566e5df3";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  


    <title> Hibernate缓存机制与Spring缓存框架的区别与联系 - 念牧童 Blog </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">念牧童 Blog</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Hibernate缓存机制与Spring缓存框架的区别与联系
        
      </h1>

      <time class="post-time">
          Apr 11 2019
      </time>
    </header>



    
            <div class="post-content">
            <ul>
<li>Hibernate一级缓存</li>
<li>Hibernate二级缓存</li>
<li>Spring缓存机制</li>
<li>Hibernate缓存与Spring缓存的比较</li>
</ul>
<h2 id="Hibernate一级缓存"><a href="#Hibernate一级缓存" class="headerlink" title="Hibernate一级缓存"></a>Hibernate一级缓存</h2><p>一级缓存是Session级别的缓存(即当前Session有效)，默认启用。</p>
<p>一级缓存的key为ID(主键)。</p>
<p>当执行load/get/list/iterator/save/update/saveOrUpdate等方法时会把得到的实体对象放入一级缓存中（只支持实体对象缓存，不支持属性的缓存），之后在同一个session范围内执行load/get/iterator等查询语句（不包括list）查询缓存过的数据时，Hibernate不会去数据库中查询。</p>
<p>当程序保存或修改实体时，不会立即同步到数据库，而是保存在一级缓存中，只有程序显示调用Session的flush()或close()方法才会刷新至数据库，这样可以减少数据库的交互，提高数据库的访问性能。</p>
<p>一级缓存清除方法：</p>
<ul>
<li>contains(object obj)</li>
<li>evict(Object obj)</li>
<li>clear()</li>
</ul>
<h2 id="Hibernate二级缓存"><a href="#Hibernate二级缓存" class="headerlink" title="Hibernate二级缓存"></a>Hibernate二级缓存</h2><p>二级缓存是SessionFactory级别的，是所有Session共享的，全局性的，需要手动开启；开启后查询时，Session会先查找一级缓存，再查找二级缓存，最后再查找数据库。</p>
<p>二级缓存的key为ID(主键)，value为实体对象。一般load（），iterate（）使用到二级缓存，list()需要结合查询缓存使用。</p>
<p>二级缓存需要指定缓存实现，如EhCache，并使用@Cache注解指定哪些实体类启用二级缓存，并指定缓存策略(一般为READ_ONLY)。</p>
<p>Hibernate缓存策略(隔离级别)：</p>
<ul>
<li>只读(READ_ONLY)</li>
<li>读/写(READ_WRITE)</li>
<li>非严格读/写(NONSTRICT_READ_WRITE)</li>
<li>事务(TRANSACTIONAL)</li>
</ul>
<h2 id="Spring缓存机制"><a href="#Spring缓存机制" class="headerlink" title="Spring缓存机制"></a>Spring缓存机制</h2><p>Spring缓存需要指定缓存实现(如EhCache)。</p>
<p>相关注解：</p>
<ul>
<li>@Cacheable</li>
<li>@CacheEvict</li>
</ul>
<p>对于一个支持缓存的方法，Spring会在其被调用后将其返回值缓存起来，以保证下次利用同样的参数来执行该方法时可以直接从缓存中获取结果，而不需要再次执行该方法。</p>
<p>缓存的key默认是通过KeyGenerator生成的，其默认生成策略如下：</p>
<ul>
<li>如果方法没有参数，则使用0作为key。</li>
<li>如果只有一个参数的话则使用该参数作为key。</li>
<li>如果参数多于一个的话则使用所有参数的hashCode作为key。</li>
</ul>
<p>实际使用中需要自定义key的生成策略，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(key = &quot;#root.target&quot; + &quot;_&quot; + &quot;#root.method&quot; + &quot;_&quot; + &quot;#p0&quot; + &quot;_&quot; + &quot;#p1&quot;)</span><br></pre></td></tr></table></figure></p>
<p>参考资料：<br><br><a href="https://www.jianshu.com/p/2a584aaafad3" target="_blank" rel="noopener">https://www.jianshu.com/p/2a584aaafad3</a><br><br><a href="https://blog.csdn.net/u013378306/article/details/52168628" target="_blank" rel="noopener">https://blog.csdn.net/u013378306/article/details/52168628</a></p>
<h2 id="Hibernate二级缓存与Spring缓存的比较"><a href="#Hibernate二级缓存与Spring缓存的比较" class="headerlink" title="Hibernate二级缓存与Spring缓存的比较"></a>Hibernate二级缓存与Spring缓存的比较</h2><p>与Hibernate SessionFactory级别的二级缓存相比，Spring缓存的级别更高，Spring缓存可以在控制器组件或业务逻辑组件级别进行缓存，这样应用完全无需重复调用底层的DAO组件（如基于Hibernate实现）的方法。</p>

            </div>
          

    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2017 -
    
    2019
    <span class="footer-author"><a class="hexo-link" href="https://github.com/jiahuixyz/">jiahui</a>.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/henryhuang/hexo-theme-polarbearsimple">Polar Bear Simple</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
