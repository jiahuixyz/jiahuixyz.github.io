<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="JVM内存管理"><link rel="alternate" href="/default" title="念牧童的个人博客"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1"><link rel="canonical" href="http://jiahuixyz.github.io/2019/03/25/JVM内存管理/"><meta name="description" content="内存区域划分线程隔离区程序计数器(Program Counter Register)：当前线程所执行的字节码的行号指示器虚拟机栈(VM Stack)：描述的是Java方法执行的内存模型,每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息；每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程；局部变量表所需"><meta property="og:type" content="article"><meta property="og:title" content="JVM内存管理"><meta property="og:url" content="http://jiahuixyz.github.io/2019/03/25/JVM内存管理/index.html"><meta property="og:site_name" content="念牧童的个人博客"><meta property="og:description" content="内存区域划分线程隔离区程序计数器(Program Counter Register)：当前线程所执行的字节码的行号指示器虚拟机栈(VM Stack)：描述的是Java方法执行的内存模型,每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息；每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程；局部变量表所需"><meta property="og:locale" content="default"><meta property="og:image" content="https://jiahuixyz.github.io/img-service/img/jvm-runtime-data-area.png"><meta property="og:updated_time" content="2019-03-25T13:43:28.865Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JVM内存管理"><meta name="twitter:description" content="内存区域划分线程隔离区程序计数器(Program Counter Register)：当前线程所执行的字节码的行号指示器虚拟机栈(VM Stack)：描述的是Java方法执行的内存模型,每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息；每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程；局部变量表所需"><meta name="twitter:image" content="https://jiahuixyz.github.io/img-service/img/jvm-runtime-data-area.png"><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1"><link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet"><script type="text/javascript">var themeConfig={fancybox:{enable:!1}}</script><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?d26aecfb935107a8552abee5566e5df3";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><title>JVM内存管理 - 念牧童的个人博客</title></head><body><div id="page"><header id="masthead"><div class="site-header-inner"><h1 class="site-title"><a href="/." class="logo">念牧童的个人博客</a></h1><nav id="nav-top"><ul id="menu-top" class="nav-top-items"><li class="menu-item"><a href="/about">About</a></li></ul></nav></div></header><div id="content"><div id="primary"><article class="post"><header class="post-header"><h1 class="post-title">JVM内存管理</h1><time class="post-time">Mar 25 2019</time></header><div class="post-content"><h2 id="内存区域划分"><a href="#内存区域划分" class="headerlink" title="内存区域划分"></a><strong>内存区域划分</strong></h2><p>线程隔离区</p><ul><li>程序计数器(Program Counter Register)：当前线程所执行的字节码的行号指示器</li><li>虚拟机栈(VM Stack)：描述的是Java方法执行的内存模型,每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息；每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程；局部变量表所需的内存空间在编译期间已经确定，在方法运行期间不会改变局部变量表的大小;栈可能抛出StackOverflowError、OutOfMemoryError异常</li><li>本地方法栈(Native Method Stack)：与虚拟机栈类似，只不过执行的方法是Native方法</li></ul><p>线程共享区</p><ul><li>堆(Heap)：存放所有对象实例和数组，<strong>堆是垃圾收集器管理的主要区域</strong>，可能抛出OutOfMemoryError异常</li><li>方法区(Method Area)：别名Non-Heap(非堆)，还被称为“永生代”(Permanent Generation)，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，可能抛出OutOfMemoryError异常</li><li>运行时常量池(Runtime Constant Pool)：是方法区的一部分，可能抛出OutOfMemoryError异常</li></ul><p>注意！在JDK1.7的HotSpot中，已经把原本放在方法区（永久代）的字符串常量池移出。</p><p><img src="https://jiahuixyz.github.io/img-service/img/jvm-runtime-data-area.png" alt="The picture was not found."></p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a><strong>垃圾收集算法</strong></h2><p>如何判断对象已死？</p><ul><li>引用计数法</li><li>可达性分析</li></ul><p>HotSpot的垃圾收集采用分代收集算法，根据对象存活周期的不同将内存划分为几块，堆被分为新生代与老年代，根据各个年代的特点采用不同的垃圾收集算法。</p><ul><li>标记-清除算法(Mark-Sweep)</li><li>复制算法(Copying)</li><li>标记-整理算法(Mark-Compact)</li></ul><p><strong>问：年轻代为什么采用的是复制算法？</strong><br><br>答：在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，所以选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</p><p><strong>问：年轻代为什么被划分成Eden空间、From Survivor空间、To Survivor空间？</strong><br><br>答：HotSpot将新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。<br><br>另外，如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保（Handle Promotion）机制进入老年代。</p><p><strong>问：老年代为什么采用的是标记清除、标记整理算法？</strong><br><br>答：因为老年代中对象存活率高，且没有额外空间对它进行分配担保。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a><strong>垃圾收集器</strong></h2><p>jdk8的HotSpot虚拟机运行在Server模式下，默认使用Parallel Scavenge+Serial Old(PS MarkSweep)的收集器组合进行内存回收，jdk9默认使用G1收集器</p><p>新生代(Young generation)收集器</p><ul><li>Serial收集器：单线程，client模式下的默认新生代收集器</li><li>ParNew收集器：Serial收集器的多线程版本</li><li>Parallel Scavenge收集器</li><li>G1收集器</li></ul><p>老年代(Tenured generation)收集器</p><ul><li>CMS(Concurrent Mark Sweep)收集器</li><li>Serial Old收集器：单线程，Serial收集器的老年代版本</li><li>Parallel Old收集器：Parallel Scavenge收集器的老年代版本</li><li>G1收集器</li></ul><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a><strong>内存分配策略</strong></h2><ul><li>对象优先在Eden分配</li><li>大对象直接进入老年代</li><li>长期存活的对象将进入老年代</li></ul></div></article></div></div><footer id="colophon"><span class="copyright-year">&copy; 2017 - 2019 <span class="footer-author"><a class="hexo-link" href="https://github.com/jiahuixyz/">liujiahui</a>.</span> <span class="power-by">Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/henryhuang/hexo-theme-polarbearsimple">Polar Bear Simple</a></span></span></footer><div class="back-to-top" id="back-to-top"><i class="iconfont icon-up"></i></div></div><script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script><script type="text/javascript" src="/js/src/theme.js?v=1.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script></body></html>